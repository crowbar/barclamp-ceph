;
; Config generated for Ceph cluster <%= node[:ceph][:clustername] %> by CHEF - do not modify
;
; This file defines cluster membership, the various locations
; that Ceph stores data, and any other runtime options.


; global
[global]
	; enable secure authentication
	auth supported = <%= node[:ceph][:defaults][:global][:auth_supported] %>

        ; allow ourselves to open a lot of files
        max open files = 131072

        ; set log file
        log file = /var/log/ceph/$name.log
        ; log_to_syslog = true        ; uncomment this line to log to syslog

        ; set up pid files
        pid file = /var/run/ceph/$name.pid

        ; If you want to run a IPv6 cluster, set this to true. Dual-stack isn't possible
        ;ms bind ipv6 = true

; monitors
;  You need at least one.  You need at least three if you want to
;  tolerate any node failures.  Always create an odd number.
[mon]
	mon data = <%= node[:ceph][:defaults][:mon][:data] %>

        ; If you are using for example the RADOS Gateway and want to have your newly created
        ; pools a higher replication level, you can set a default
        ;osd pool default size = 3

        ; You can also specify a CRUSH rule for new pools
        ; Wiki: http://ceph.newdream.net/wiki/Custom_data_placement_with_CRUSH
        ;osd pool default crush rule = 0

        ; Timing is critical for monitors, but if you want to allow the clocks to drift a
        ; bit more, you can specify the max drift.
        ;mon clock drift allowed = 1

        ; Tell the monitor to backoff from this warning for 30 seconds
        ;mon clock drift warn backoff = 30

	; logging, for debugging monitor crashes, in order of
	; their likelihood of being helpful :)
	;debug ms = 1
	;debug mon = 20
	;debug paxos = 20
	;debug auth = 20

<% @monitors.sort_by { |mon| mon[:name] }.each do |monitor| %>
[mon.<%= "#{monitor[:name]}-#{@clustername}" %>]
	host = <%= monitor[:name] %>
	mon addr = <%=  monitor[:address] %>:6789
<% end unless @monitors.empty? %>

; mds
;  You need at least one.  Define two to get a standby.
[mds]
	; where the mds keeps it's secret encryption keys
	keyring = <%= node[:ceph][:defaults][:global][:keyring] %>

	; mds logging to debug issues.
	;debug ms = 1
	;debug mds = 20

<% @mdss.sort_by { |mds| mds[:hostname] }.each do |mds| %>
[mds.<%= mds[:hostname] %>]
	host = <%= mds[:hostname] %>
<% end unless @mdss.empty? %>

; osd
;  You need at least one.  Two if you want data to be replicated.
;  Define as many as you like.
[osd]
	; This is where the osd expects its data
	osd data = <%= node[:ceph][:defaults][:osd][:data] %>

	; Ideally, make the journal a separate disk or partition.
 	; 1-10GB should be enough; more if you have fast or many
 	; disks.  You can use a file under the osd data dir if need be
 	; (e.g. /data/$name/journal), but it will be slower than a
 	; separate disk or partition.
        ; This is an example of a file-based journal.
	osd journal = <%= node[:ceph][:defaults][:osd][:journal] %>
	osd journal size = <%= node[:ceph][:defaults][:osd][:journal_size] %>

        ; If you want to run the journal on a tmpfs (don't), disable DirectIO
        ;journal dio = false

        ; You can change the number of recovery operations to speed up recovery
        ; or slow it down if your machines can't handle it
        ; osd recovery max active = 3

	; osd logging to debug osd issues, in order of likelihood of being
	; helpful
	;debug ms = 1
	;debug osd = 20
	;debug filestore = 20
	;debug journal = 20

	fstype = xfs

	; ### The below options only apply if you're using mkcephfs
	; ### and the devs options
        ; The filesystem used on the volumes
        osd mkfs type = xfs
        ; If you want to specify some other mount options, you can do so.
        ; for other filesystems use 'osd mount options $fstype'
	osd mount options xfs = rw,noatime
	; The options used to format the filesystem via mkfs.$fstype
        ; for other filesystems use 'osd mkfs options $fstype'
	; osd mkfs options btrfs =

<% @osds.sort_by { |osd| osd[:ceph][:osd][:index] }.each do |osd| %>
[osd.<%= osd[:ceph][:osd][:index] %>]
	host = <%= osd[:hostname] %>
<% end unless @osds.empty? %>

<% @extra_osds_data.sort_by { |osd| osd[:index] }.each do |osd| %>
[osd.<%= osd[:index] %>]
	host = <%= osd[:hostname] %>
        cluster addr = <%= osd[:cluster_addr] %>:<%= osd[:cluster_port] %>
        public addr = <%= osd[:public_addr] %>:<%= osd[:public_port] %>
        devs = <%= osd[:device] %>
<% end %>
